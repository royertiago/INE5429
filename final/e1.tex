\documentclass[10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definição}

\begin{document}

\title{
    INE5429 --- Segurança em Computação \\[1ex]
    Protocolo de segredo compartilhado \\
    que permite a alteração da estrutura de acesso \\[1ex]
    \makebox{Descrição do tema e proposta de trabalho prático}
}
\author{Tiago Royer}
\date{2 de novembro de 2015}
\maketitle

\begin{abstract}
    Um protocolo de segredo compartilhado
    é um método de dividir um segredo $s$
    (uma chave criptográfica, por exemplo)
    entre vários participantes,
    de forma que seja necessário algum conjunto específico destas partes
    para que possamos reconstruir $s$.
    Por exemplo,
    num esquema de segredo compatrilhado com limiar $t$,
    são necessárias ao menos $t$ ``fatias'' do segredo $s$
    para que ele seja reconstruído;
    conhecimento de apenas $t-1$ fatias não é suficiente para reconstruir $s$.

    Neste trabalho,
    estudaremos um protocolo de segredo compartilhado
    que permite adicionar e remover participantes da estrutura de acesso,
    sem que haja a necessidade de redistribuir as partes de $s$.
\end{abstract}

\section{Introdução}

A ideia de \emph{segredo compartilhado}
surge da necessidade de se dividir a responsabilidade sobre uma chave secreta $s$,
mas sem usar replicação;
isto é,
em vez de cada participante possuir sua cópia de $s$,
cada participante possui apenas uma parte,
e é necessário reunir vários participantes para reconstruir o segredo.

Por exemplo,
um país que detenha armas nucleares
pode bloquear o lançamento com um código de segurança,
que será compartilhado entre o Presidente da República e o Ministro da Defesa.
(Chamaremos estes dois participantes de $P_1$ e $P_2$)
Ambos precisam estar presentes para que o lançamento possa ser efetuado.

Uma forma simples de implementar o compartilhamento, neste caso,
é dividir a chave em duas partes,
e dar uma para cada participante.
Por exemplo,
se o segredo for \texttt{CUSTODIO},
o \emph{dealer}
(entidade confiável que será encarregada de dividir o segredo)
pode entregar \texttt{CUST....} para $P_1$
e \texttt{....ODIO} para $P_2$.
$P_1$ e $P_2$ precisam cooperar para reconstruir a chave original.

Caso houvessem três membros
($P_1$, $P_2$ e $P_3$),
poderíamos dividir o segredo em três partes,
e assim por diante;
entretanto,
neste esquema de compartilhamento de segredo,
o conhecimento de alguma das partes
facilita a descoberta do segredo.
Isto é,
sem qualquer informação sobre as partes,
um ataque de força-bruta contra o segredo
exigiria
\begin{equation*}
    (26)^8 \approx 2*10^{11} \approx 2^{37}
\end{equation*}
tentativas,
enquanto que, sabendo uma das partes
(que dá conhecimento sobre $4$ letras)
reduz o esforço para
\begin{equation*}
    (26)^4 \approx 4*10^{6} \approx 2^{18}.
\end{equation*}
Esta propriedade deste esquema é indesejável,
pois, idealmente,
o conhecimento de todas as partes, exceto uma,
não deve dar mais informação sobre o segredo
do que conhecer nenhuma.

Uma forma de implementar isso
(neste exemplo)
é interpretar cada letra como um número
($\mathtt A = 0$, $\mathtt B = 1$, etc.)
e utilizar adição em $\mathbb Z_{26}$.
Para cada letra $\alpha$ do segredo,
gere aleatoriamente outra letra $\beta$,
construa $\gamma = \alpha - \beta \pmod{26}$,
e entregue $\beta$ para $P_1$ e $\gamma$ para $P_2$.
Então,
para reconstruir o segredo original,
basta computar
\begin{equation}
    \alpha = \beta + \gamma \pmod{26}.
    \label{eq:modular_sharing}
\end{equation}

Por exemplo,
digamos que a sequência de valores aleatórios gere a palavra
\texttt{RETUPMOC};
esta é a ``fatia'' que será entregue a $P_1$.
Para calcular a parte de $P_2$,
fazemos
\begin{align*}
    \mathtt C - \mathtt R &= \mathtt L \pmod{26} \\
    \mathtt U - \mathtt E &= \mathtt Q \pmod{26} \\
    \mathtt S - \mathtt T &= \mathtt Y \pmod{26} \\
    \vdots \quad & \quad \vdots
\end{align*}
Ao final,
teremos a parte de $P_2$: \texttt{LQZZZRUM}.
Para reconstruir o segredo,
basta somar as duas partes,
letra por letra,
módulo $26$.
(Usando números binários em vez de base $26$,
usaríamos a operação ou-exclusivo.)
Podemos extender este mecanismo para mais participantes
subtraindo mais números na equação~\ref{eq:modular_sharing}
Observe que ter uma das partes do segredo
apenas informa seu tamanho;
isto é,
não ganhamos informação suficiente para obter o segredo
sem todas as partes.

Entretanto,
caso uma das partes seja destruída
(ou perdida, ou de alguma forma não esteja disponível),
não é possível reconstruir o segredo original.
Poderíamos, por exemplo,
querer entregar uma parte do segredo ao vice-presidente ($P_3$),
de forma que qualquer dois dos três ($P_1$, $P_2$ e $P_3$)
pudesse reconstruir o segredo.
Usando a ideia anterior de dividir a chave,
podemos fazer algo como
\begin{align*}
    \texttt{CUSTO...} \\
    \texttt{CUS..DIO} \\
    \texttt{...TODIO}
\end{align*}
Quaisquer dois pares destas partes é suficiente para reconstruir o segredo;
entretanto,
voltamos a ter o mesmo problema de que a possesão de algumas das partes
reduz o esforço computacional.
Existem algoritmos
(como o esquema de Shamir)
que permitem fazer este tipo de compartilhamento de segredo
sem este problema.

\section{Esquema de Shamir}

\begin{definition}
    Um \emph{esquema de limiar $(t, n)$}
    é um método de compartilhamento de segredos
    que envolve $n$ participantes $P_1, \dots, P_n$.
    Cada participante $P_i$ receberá uma \emph{quota}%
    \footnote{Do inglês \emph{share}}
    $s_i$ de um segredo $s$.
    Qualquer conjunto de $t$ quotas distintas
    pode ser usado para reconstruir o segredo original $s$ eficientemente;
    entretanto,
    não é possível obter $s$ usando apenas $t-1$ quotas.
    \cite{Shamir1979}
\end{definition}

O exemplo citado na seção anterior corresponde a um esquema $(2, 3)$.

O esquema de Shamir~\cite{Shamir1979} implementa um desses esquemas.
A ideia é usar interpolação polinomial.
Um polinômio $p$ de grau $t-1$ estará completamente determinado
se $t$ diferentes pares $(x, p(x))$ forem conhecidos;
podemos, então,
escolher o segredo como sendo sempre $p(0)$.
Com $t$ diferentes pares,
podemos reconstruir o polinômio $p$ e restaurar $s = p(0)$;
por outro lado,
com $t-1$ pares,
existem infinitos polinômios de grau $t-1$ que passam por aquele ponto,
portanto não conseguimos determinar $s$.

Formalmente:

\begin{definition}
    Seja $\{P_1, \dots, P_n\}$ um conjunto de participantes
    e $s$ o segredo que deseja ser compartilhado.
    O esquema de Shamir~\cite{Shamir1979}
    consiste em escolher aleatoriamente um polinômio $p$
    de grau $t-1$
    da forma
    \begin{equation*}
        p(x) = a_0 + a_1 x^1 + a_2 x^2 + \dots + a_{t-1} x^{t-1},
    \end{equation*}
    em que $a_0 = s$.
    Então, cada uma das quotas do segredo é dada por
    \begin{equation*}
        s_i = (i, p(i)).
    \end{equation*}
\end{definition}

A ideia é que este polinômio seja construído sobre algum corpo finito;
por exemplo, $\mathbb Z_p$ para algum primo grande $p$.
Neste corpo,
podemos usar a fórmula de Langrange para interpolação polinômial
sem erros de arredondamento.

\begin{theorem}
    O esquema de Shamir é um esquema de limiar $(t, n)$.
\end{theorem}

\begin{proof}
    A geração das quotas foi estabelecida na própria definição do esquema.
    Iremos mostrar que é possível reconstruir o segredo
    usando exatamente $t$ quotas,
    mas que não ganhamos informação alguma a partir de $t-1$ quotas.

    Dados $k$ pares $(x_1, y_1), \dots, (x_k, y_k)$,
    use a fórmula de interpolação de Lagrange para reconstruir o polinômio $p$.
    \begin{equation}
        p(x) = \sum_{i = 1}^k y_i
                \prod_{\begin{smallmatrix}1 \leq j \leq k\\j \neq i\end{smallmatrix}}
                    \frac{x - x_j}{x_i - x_j}
        \label{eq:lagrange}
    \end{equation}
    Este polinômio satisfará $p(x_i) = y_i$;
    além disso, é o único polinômio de grau $t-1$ que passa por esses pontos.
    Portanto,
    $p$ é efetivamente reconstruído,
    e podemos calcular $s = p(0)$.

    Por outro lado,
    podemos usar exatamente a fórmula de interpolação de Lagrange
    para mostrar que, com $t-1$ quotas,
    nada descobrimos a respeito do segredo.
    Para qualquer candidato a segredo $s'$,
    podemos adicionar, na equação~\ref{eq:lagrange},
    o par $(0, s')$
    no lugar do par $(x_k, y_k)$;
    desta forma,
    teremos um polinômio que,
    de fato,
    interpola os pontos $(x_1, y_1), \dots, (x_{n-1}, y_{n-1})$,
    mas que $p(0) = s'$.
    Portanto,
    não podemos determinar o polinômio com $t-1$
    (ou menos)
    quotas.
\end{proof}

\section{Características do esquema de Shamir}

A despeito de ter sido um dos primeiros esquemas propostos,
o esquema de Shamir possui várias qualidades importantes.

O esquema é incondicionalmente seguro\footnote{
    Os artigos (em inglês)
    se referem a esta propriedade como
    ``\emph{information-theoretic} secure'';
    isto é,
    o protocolo é seguro do ponto de vista da teoria da informação.
}
\cite{Krawczyk1993};
quer dizer,
um atacante com $t-1$ quotas do segredo,
mesmo que possua poder computacional infinito,
não possui vantagem sobre um atacante com nenhuma quota do segredo.

O tamanho das quotas é aproximadamente do mesmo tamanho do segredo.
Se a informação $x_i$ do par $(x_i, y_i)$ for pública,
todas as quotas do segredo $s$ passam a pertencer ao domínio de $s$,
que é o que caracteriza um \emph{esquema ideal}~\cite{Brickell1990}.
\footnote{
    Sob a exigência de ser incondicionalmente seguro,
    as quotas precisam ter, no mínimo,
    o tamanho do segredo a ser compartilhado.
    Krawczyk~\cite{Krawczyk1993} construiu um esquema de limiar $(t, n)$
    que é \emph{computacionalmente} seguro
    tal que, para um segredo $s$,
    as quotas possuem tamanho $O(|s|/m)$.
    (Ser computacionalmente seguro
    significa ter sua segurança
    baseada na intratabilidade de algum problema computacional;
    isto é,
    o protocolo pode ser vulnerável a um ataque de força-bruta,
    mas isso é o melhor que pode ser feito.)
}

Além disso,
caso o dealer ainda esteja disponível,
novos participantes podem ser adicionados;
basta gerar um novo par $(x_{n+1}, p(x_{n+1})$
para que um novo participante possua sua quota do segredo.
Shamir~\cite{Shamir1979} observa que,
ao menos em teoria,
é possível remover uma quota $s_i$ sem comprometer a estrutura de acesso;
entretanto,
o participante $P_i$ precisaria garantir a destruição de $s_i$
--- nem mesmo ele pode ter acesso a $s_i$ depois de destruída.

Entretanto,
se estamos expulsando o participante $P_i$ do esquema,
não parece ser uma hipótese razoável
assumir que $P_i$ irá pacificamente destruir $s_i$.
Podemos querer removê-lo do esquema
por descobrir que aquele nó foi comprometido;
precisamos de algum mecanismo externo para invalidar a quota $s_i$.

\section{Esquema de Pinch}
\section{Limitações do esquema de Pinch}

O maior problema do esquema de Pinch é o quadro de avisos.
Para $n$ participantes,
o quadro pode ter tamanho proporcional a $2^n$
para estruturas de acesso específicas.
Existem propostas que tentam remediar isso,
mas sempre um novo problema é introduzido.

Valls, Villar e Márquez~\cite{VallsVillarMarqez1999}
constroem um protocolo de segredo compartilhado
que permite alteração na estrutura de acesso
usando apenas $O(n)$ de espaço para o quadro de avisos.
Entretanto,
a geração deste quadro de avisos é baseada
num protocolo de segredo compartilhado de Brickell,
a construção do espaço vetorial\footnote{
    Do inglês \emph{vector space construction}.
}
\cite{Brickell1990}.
O livro de Stinson~\cite[p.~499]{Stinson2006} de 2006
afirma que, para estruturas de acesso arbitrárias,
a tarefa de construir estes espaços vetoriais
só é feita por tentativa e erro
--- ou seja, este problema é intratável.
O artigo de Atici~\cite{Atici2013} de 2013
apresenta dois algoritmos para casos particulares;
mas, além de nenhum deles resolver o problema do esquema de limiar $(t, n)$,
Atici ainda diz que o caso geral requer força-bruta.

\bibliographystyle{plain}
\bibliography{bibliografia}

\end{document}
