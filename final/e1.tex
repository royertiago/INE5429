\documentclass[10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}

\usepackage{amsmath}
\usepackage{amssymb}

\begin{document}

\title{
    INE5429 --- Segurança em Computação \\[1ex]
    Protocolo de segredo compartilhado \\
    que permite a alteração da estrutura de acesso \\[1ex]
    \makebox{Descrição do tema e proposta de trabalho prático}
}
\author{Tiago Royer}
\date{2 de novembro de 2015}
\maketitle

\begin{abstract}
    Um protocolo de segredo compartilhado
    é um método de dividir um segredo $s$
    (uma chave criptográfica, por exemplo)
    entre vários participantes,
    de forma que seja necessário algum conjunto específico destas partes
    para que possamos reconstruir $s$.
    Por exemplo,
    num esquema de segredo compatrilhado com limiar $t$,
    são necessárias ao menos $t$ ``fatias'' do segredo $s$
    para que ele seja reconstruído;
    conhecimento de apenas $t-1$ fatias não é suficiente para reconstruir $s$.

    Neste trabalho,
    estudaremos um protocolo de segredo compartilhado
    que permite adicionar e remover participantes da estrutura de acesso,
    sem que haja a necessidade de redistribuir as partes de $s$.
\end{abstract}

\section{Introdução}

A ideia de \emph{segredo compartilhado}
surge da necessidade de se dividir a responsabilidade sobre uma chave secreta $s$,
mas sem usar replicação;
isto é,
em vez de cada participante possuir sua cópia de $s$,
cada participante possui apenas uma parte,
e é necessário reunir vários participantes para reconstruir o segredo.

Por exemplo,
um país que detenha armas nucleares
pode bloquear o lançamento com um código de segurança,
que será compartilhado entre o Presidente da República e o Ministro da Defesa.
(Chamaremos estes dois participantes de $P_1$ e $P_2$)
Ambos precisam estar presentes para que o lançamento possa ser efetuado.

Uma forma simples de implementar o compartilhamento, neste caso,
é dividir a chave em duas partes,
e dar uma para cada participante.
Por exemplo,
se o segredo for \texttt{CUSTODIO},
o \emph{dealer}
(entidade confiável que será encarregada de dividir o segredo)
pode entregar \texttt{CUST....} para $P_1$
e \texttt{....ODIO} para $P_2$.
$P_1$ e $P_2$ precisam cooperar para reconstruir a chave original.

Caso houvessem três membros
($P_1$, $P_2$ e $P_3$),
poderíamos dividir o segredo em três partes,
e assim por diante;
entretanto,
neste esquema de compartilhamento de segredo,
o conhecimento de alguma das partes
facilita a descoberta do segredo.
Isto é,
sem qualquer informação sobre as partes,
um ataque de força-bruta contra o segredo
exigiria
\begin{equation*}
    (26)^8 \approx 2*10^{11} \approx 2^{37}
\end{equation*}
tentativas,
enquanto que, sabendo uma das partes
(que dá conhecimento sobre $4$ letras)
reduz o esforço para
\begin{equation*}
    (26)^4 \approx 4*10^{6} \approx 2^{18}.
\end{equation*}
Esta propriedade deste esquema é indesejável,
pois, idealmente,
o conhecimento de todas as partes, exceto uma,
não deve dar mais informação sobre o segredo
do que conhecer nenhuma.

Uma forma de implementar isso
(neste exemplo)
é interpretar cada letra como um número
($\mathtt A = 0$, $\mathtt B = 1$, etc.)
e utilizar adição em $\mathbb Z_{26}$.
Para cada letra $\alpha$ do segredo,
gere aleatoriamente outra letra $\beta$,
construa $\gamma = \alpha - \beta \pmod{26}$,
e entregue $\beta$ para $P_1$ e $\gamma$ para $P_2$.
Então,
para reconstruir o segredo original,
basta computar
\begin{equation*}
    \alpha = \beta + \gamma \pmod{26}.
    \label{eq:modular_sharing}
\end{equation*}

Por exemplo,
digamos que a sequência de valores aleatórios gere a palavra
\texttt{RETUPMOC};
esta é a ``fatia'' que será entregue a $P_1$.
Para calcular a parte de $P_2$,
fazemos
\begin{align*}
    \mathtt C - \mathtt R &= \mathtt L \pmod{26} \\
    \mathtt U - \mathtt E &= \mathtt Q \pmod{26} \\
    \mathtt S - \mathtt T &= \mathtt Y \pmod{26} \\
    \vdots \quad & \quad \vdots
\end{align*}
Ao final,
teremos a parte de $P_2$: \texttt{LQZZZRUM}.
Para reconstruir o segredo,
basta somar as duas partes,
letra por letra,
módulo $26$.
(Usando números binários em vez de base $26$,
usaríamos a operação ou-exclusivo.)
Podemos extender este mecanismo para mais participantes
subtraindo mais números na equação~\ref{eq:modular_sharing}
Observe que ter uma das partes do segredo
apenas informa seu tamanho;
isto é,
não ganhamos informação suficiente para obter o segredo
sem todas as partes.

Entretanto,
caso uma das partes seja destruída
(ou perdida, ou de alguma forma não esteja disponível),
não é possível reconstruir o segredo original.
Poderíamos, por exemplo,
querer entregar uma parte do segredo ao vice-presidente ($P_3$),
de forma que qualquer dois dos três ($P_1$, $P_2$ e $P_3$)
pudesse reconstruir o segredo.
Usando a ideia anterior de dividir a chave,
podemos fazer algo como
\begin{align*}
    \texttt{CUSTO...} \\
    \texttt{CUS..DIO} \\
    \texttt{...TODIO}
\end{align*}
Quaisquer dois pares destas partes é suficiente para reconstruir o segredo;
entretanto,
voltamos a ter o mesmo problema de que a possesão de algumas das partes
reduz o esforço computacional.
Existem algoritmos
(como o esquema de Shamir)
que permitem fazer este tipo de compartilhamento de segredo
sem este problema.

\section{Esquema de Shamir}
\section{Limitações inerentes ao esquema}
\section{Esquema de Pinch}
\section{Limitações do esquema de Pinch}
\bibliographystyle{plain}
\bibliography{bibliografia}

\end{document}
