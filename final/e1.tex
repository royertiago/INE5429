\documentclass[10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definição}

\begin{document}

\title{
    INE5429 --- Segurança em Computação \\[1ex]
    Protocolo de segredo compartilhado \\
    que permite a alteração da estrutura de acesso \\[1ex]
    \makebox{Descrição do tema e proposta de trabalho prático}
}
\author{Tiago Royer}
\date{2 de novembro de 2015}
\maketitle

\begin{abstract}
    Um protocolo de segredo compartilhado
    é um método de dividir um segredo $s$
    (uma chave criptográfica, por exemplo)
    entre vários participantes,
    de forma que seja necessário algum conjunto específico destas partes
    para que possamos reconstruir $s$.
    Por exemplo,
    num esquema de segredo compatrilhado com limiar $t$,
    são necessárias ao menos $t$ ``fatias'' do segredo $s$
    para que ele seja reconstruído;
    conhecimento de apenas $t-1$ fatias não é suficiente para reconstruir $s$.

    Neste trabalho,
    estudaremos um protocolo de segredo compartilhado
    que permite adicionar e remover participantes da estrutura de acesso,
    sem que haja a necessidade de redistribuir as partes de $s$.
\end{abstract}

\section{Introdução}

A ideia de \emph{segredo compartilhado}
surge da necessidade de se dividir a responsabilidade sobre uma chave secreta $s$,
mas sem usar replicação;
isto é,
em vez de cada participante possuir sua cópia de $s$,
cada participante possui apenas uma parte,
e é necessário reunir vários participantes para reconstruir o segredo.

Por exemplo,
um país que detenha armas nucleares
pode bloquear o lançamento com um código de segurança,
que será compartilhado entre o Presidente da República e o Ministro da Defesa.
(Chamaremos estes dois participantes de $P_1$ e $P_2$)
Ambos precisam estar presentes para que o lançamento possa ser efetuado.

Uma forma simples de implementar o compartilhamento, neste caso,
é dividir a chave em duas partes,
e dar uma para cada participante.
Por exemplo,
se o segredo for \texttt{CUSTODIO},
o \emph{dealer}
(entidade confiável que será encarregada de dividir o segredo)
pode entregar \texttt{CUST....} para $P_1$
e \texttt{....ODIO} para $P_2$.
$P_1$ e $P_2$ precisam cooperar para reconstruir a chave original.

Caso houvessem três membros
($P_1$, $P_2$ e $P_3$),
poderíamos dividir o segredo em três partes,
e assim por diante;
entretanto,
neste esquema de compartilhamento de segredo,
o conhecimento de alguma das partes
facilita a descoberta do segredo.
Isto é,
sem qualquer informação sobre as partes,
um ataque de força-bruta contra o segredo
exigiria
\begin{equation*}
    (26)^8 \approx 2*10^{11} \approx 2^{37}
\end{equation*}
tentativas,
enquanto que, sabendo uma das partes
(que dá conhecimento sobre $4$ letras)
reduz o esforço para
\begin{equation*}
    (26)^4 \approx 4*10^{6} \approx 2^{18}.
\end{equation*}
Esta propriedade deste esquema é indesejável,
pois, idealmente,
o conhecimento de todas as partes, exceto uma,
não deve dar mais informação sobre o segredo
do que conhecer nenhuma.

Uma forma de implementar isso
(neste exemplo)
é interpretar cada letra como um número
($\mathtt A = 0$, $\mathtt B = 1$, etc.)
e utilizar adição em $\mathbb Z_{26}$.
Para cada letra $\alpha$ do segredo,
gere aleatoriamente outra letra $\beta$,
construa $\gamma = \alpha - \beta \pmod{26}$,
e entregue $\beta$ para $P_1$ e $\gamma$ para $P_2$.
Então,
para reconstruir o segredo original,
basta computar
\begin{equation}
    \alpha = \beta + \gamma \pmod{26}.
    \label{eq:modular_sharing}
\end{equation}

Por exemplo,
digamos que a sequência de valores aleatórios gere a palavra
\texttt{RETUPMOC};
esta é a ``fatia'' que será entregue a $P_1$.
Para calcular a parte de $P_2$,
fazemos
\begin{align*}
    \mathtt C - \mathtt R &= \mathtt L \pmod{26} \\
    \mathtt U - \mathtt E &= \mathtt Q \pmod{26} \\
    \mathtt S - \mathtt T &= \mathtt Y \pmod{26} \\
    \vdots \quad & \quad \vdots
\end{align*}
Ao final,
teremos a parte de $P_2$: \texttt{LQZZZRUM}.
Para reconstruir o segredo,
basta somar as duas partes,
letra por letra,
módulo $26$.
(Usando números binários em vez de base $26$,
usaríamos a operação ou-exclusivo.)
Podemos extender este mecanismo para mais participantes
subtraindo mais números na equação~\ref{eq:modular_sharing}
Observe que ter uma das partes do segredo
apenas informa seu tamanho;
isto é,
não ganhamos informação suficiente para obter o segredo
sem todas as partes.

Entretanto,
caso uma das partes seja destruída
(ou perdida, ou de alguma forma não esteja disponível),
não é possível reconstruir o segredo original.
Poderíamos, por exemplo,
querer entregar uma parte do segredo ao vice-presidente ($P_3$),
de forma que qualquer dois dos três ($P_1$, $P_2$ e $P_3$)
pudesse reconstruir o segredo.
Usando a ideia anterior de dividir a chave,
podemos fazer algo como
\begin{align*}
    \texttt{CUSTO...} \\
    \texttt{CUS..DIO} \\
    \texttt{...TODIO}
\end{align*}
Quaisquer dois pares destas partes é suficiente para reconstruir o segredo;
entretanto,
voltamos a ter o mesmo problema de que a possesão de algumas das partes
reduz o esforço computacional.
Existem algoritmos
(como o esquema de Shamir)
que permitem fazer este tipo de compartilhamento de segredo
sem este problema.

\section{Esquema de Shamir}

\begin{definition}
    Um \emph{esquema de limiar $(t, n)$}
    é um método de compartilhamento de segredos
    que envolve $n$ participantes $P_1, \dots, P_n$.
    Cada participante $P_i$ receberá uma \emph{quota}%
    \footnote{Do inglês \emph{share}}
    $s_i$ de um segredo $s$.
    Qualquer conjunto de $t$ quotas distintas
    pode ser usado para reconstruir o segredo original $s$ eficientemente;
    entretanto,
    não é possível obter $s$ usando apenas $t-1$ quotas.
    \cite{Shamir1979}
\end{definition}

O exemplo citado na seção anterior corresponde a um esquema $(2, 3)$.

O esquema de Shamir~\cite{Shamir1979} implementa um desses esquemas.
A ideia é usar interpolação polinomial.
Um polinômio $p$ de grau $t-1$ estará completamente determinado
se $t$ diferentes pares $(x, p(x))$ forem conhecidos;
podemos, então,
escolher o segredo como sendo sempre $p(0)$.
Com $t$ diferentes pares,
podemos reconstruir o polinômio $p$ e restaurar $s = p(0)$;
por outro lado,
com $t-1$ pares,
existem infinitos polinômios de grau $t-1$ que passam por aquele ponto,
portanto não conseguimos determinar $s$.

Formalmente:

\begin{definition}
    Seja $\{P_1, \dots, P_n\}$ um conjunto de participantes
    e $s$ o segredo que deseja ser compartilhado.
    O esquema de Shamir~\cite{Shamir1979}
    consiste em escolher aleatoriamente um polinômio $p$
    de grau $t-1$
    da forma
    \begin{equation*}
        p(x) = a_0 + a_1 x^1 + a_2 x^2 + \dots + a_{t-1} x^{t-1},
    \end{equation*}
    em que $a_0 = s$.
    Então, cada uma das quotas do segredo é dada por
    \begin{equation*}
        s_i = (i, p(i)).
    \end{equation*}
\end{definition}

A ideia é que este polinômio seja construído sobre algum corpo finito;
por exemplo, $\mathbb Z_p$ para algum primo grande $p$.
Neste corpo,
podemos usar a fórmula de Langrange para interpolação polinômial
sem erros de arredondamento.

\begin{theorem}
    O esquema de Shamir é um esquema de limiar $(t, n)$.
\end{theorem}

\begin{proof}
    A geração das quotas foi estabelecida na própria definição do esquema.
    Iremos mostrar que é possível reconstruir o segredo
    usando exatamente $t$ quotas,
    mas que não ganhamos informação alguma a partir de $t-1$ quotas.

    Dados $k$ pares $(x_1, y_1), \dots, (x_k, y_k)$,
    use a fórmula de interpolação de Lagrange para reconstruir o polinômio $p$.
    \begin{equation}
        p(x) = \sum_{i = 1}^k y_i
                \prod_{\begin{smallmatrix}1 \leq j \leq k\\j \neq i\end{smallmatrix}}
                    \frac{x - x_j}{x_i - x_j}
        \label{eq:lagrange}
    \end{equation}
    Este polinômio satisfará $p(x_i) = y_i$;
    além disso, é o único polinômio de grau $t-1$ que passa por esses pontos.
    Portanto,
    $p$ é efetivamente reconstruído,
    e podemos calcular $s = p(0)$.

    Por outro lado,
    podemos usar exatamente a fórmula de interpolação de Lagrange
    para mostrar que, com $t-1$ quotas,
    nada descobrimos a respeito do segredo.
    Para qualquer candidato a segredo $s'$,
    podemos adicionar, na equação~\ref{eq:lagrange},
    o par $(0, s')$
    no lugar do par $(x_k, y_k)$;
    desta forma,
    teremos um polinômio que,
    de fato,
    interpola os pontos $(x_1, y_1), \dots, (x_{n-1}, y_{n-1})$,
    mas que $p(0) = s'$.
    Portanto,
    não podemos determinar o polinômio com $t-1$
    (ou menos)
    quotas.
\end{proof}

\section{Características do esquema de Shamir}

A despeito de ter sido um dos primeiros esquemas propostos,
o esquema de Shamir possui várias qualidades importantes.

O esquema é incondicionalmente seguro\footnote{
    Os artigos (em inglês)
    se referem a esta propriedade como
    ``\emph{information-theoretic} secure'';
    isto é,
    o protocolo é seguro do ponto de vista da teoria da informação.
}
\cite{Krawczyk1993};
quer dizer,
um atacante com $t-1$ quotas do segredo,
mesmo que possua poder computacional infinito,
não possui vantagem sobre um atacante com nenhuma quota do segredo.

O tamanho das quotas é aproximadamente do mesmo tamanho do segredo.
Se a informação $x_i$ do par $(x_i, y_i)$ for pública,
todas as quotas do segredo $s$ passam a pertencer ao domínio de $s$,
que é o que caracteriza um \emph{esquema ideal}~\cite{Brickell1990}.
\footnote{
    Sob a exigência de ser incondicionalmente seguro,
    as quotas precisam ter, no mínimo,
    o tamanho do segredo a ser compartilhado.
    Krawczyk~\cite{Krawczyk1993} construiu um esquema de limiar $(t, n)$
    que é \emph{computacionalmente} seguro
    tal que, para um segredo $s$,
    as quotas possuem tamanho $O(|s|/m)$.
    (Ser computacionalmente seguro
    significa ter sua segurança
    baseada na intratabilidade de algum problema computacional;
    isto é,
    o protocolo pode ser vulnerável a um ataque de força-bruta,
    mas isso é o melhor que pode ser feito.)
}

Além disso,
caso o dealer ainda esteja disponível,
novos participantes podem ser adicionados;
basta gerar um novo par $(x_{n+1}, p(x_{n+1}))$
para que um novo participante possua sua quota do segredo.
Shamir~\cite{Shamir1979} observa que,
ao menos em teoria,
é possível remover uma quota $s_i$ sem comprometer a estrutura de acesso;
entretanto,
o participante $P_i$ precisaria garantir a destruição de $s_i$
--- nem mesmo ele pode ter acesso a $s_i$ depois de destruída.

Entretanto,
se estamos expulsando o participante $P_i$ do esquema,
não parece ser uma hipótese razoável
assumir que $P_i$ irá pacificamente destruir $s_i$.
Podemos querer removê-lo do esquema
por descobrir que aquele nó foi comprometido;
precisamos de algum mecanismo externo para invalidar a quota $s_i$.

Todos os algoritmos analisados (\cite{
    VallsVillarMarquez1999,
    BlakleyBlakleyChanMassey1993,
    ChenGollmanMitchellWild1997,
    Sun1999,
    Cachin1995,
    Pinch1996%
})
adicionam informação pública ao protocolo
por meio de um \emph{quadro de avisos}\footnote{
    Do inglês \emph{noticeboard}.
}.
Para obter acesso ao segredo,
além de juntar $t$ quotas,
é necessário buscar alguma informação no quadro de avisos
para executar o algoritmo de reconstrução.
Caso seja necessário invalidar as quotas,
basta alterar correspondentemente o quadro de avisos.

Observe que a existência de um quadro de avisos
é necessária para a invalidação de quotas;
caso contrário,
um conjunto de $t$ participantes
poderia simplesmente usar suas quotas originais
(que não foram destruídas)
para obter acesso ao segredo.
De fato,
em alguns casos,
é necessário alterar o segredo $s$:
como a informação do quadro de avisos é pública,
qualquer membro poderia manter um banco de dados com todo o histórico do quadro,
possibilitando a reconstrução de $s$
mesmo após o quadro ser alterado.

Cachin~\cite{Cachin1995} descreve um possível caso de uso para este algoritmo.
Por exemplo,
um banco ou um laboratório
podem ter uma área de segurança máxima,
em que ao menos um gerente e dois funcionários são necessários para acessá-lo.
Caso um gerente seja demitido,
é necessário trocar a chave de segurança desta área
(isto é, alterar o segredo $s$);
mas é possível fazer isso sem precisar alterar as quotas dos demais funcionários.
O esquema de Cachin,
que será apresentado a seguir,
permite esta alteração.

\section{Esquema de Cachin-Pinch \cite{Pinch1996}}

\begin{definition}
    Seja $\mathcal P = \{P_1, \dots, P_n\}$ um conjunto de participantes.
    Uma \emph{estrutura de acesso} sobre $\mathcal P$
    é um conjunto $\Gamma \subseteq 2^\mathcal P$
    tal que,
    se $X \in \Gamma$ e $X \subseteq Y$,
    então $Y \in \Gamma$
    --- isto é, $\Gamma$ é um conjunto monótono.
    Os elementos de $\Gamma$ são os conjuntos qualificados a reconstruir o segredo.

    A base de $\Gamma$, denotada por $\Gamma_0$,
    é o subconjunto de $\Gamma$
    que contém os conjuntos qualificados mínimos;
    isto é,
    \begin{equation*}
        \Gamma_0 = \{X \in \Gamma \mid \neg \exists Y \in \Gamma : Y \subsetneq X \}.
    \end{equation*}
\end{definition}

Todo esquema de limiar $(t, n)$
descreve uma estrutura de acesso
\begin{equation*}
    \Gamma = \{X \subseteq \mathcal P \mid |X| \geq t\};
\end{equation*}
portanto,
estruturas de acesso são uma generalização dos esquemas de limiar.
O esquema de Cachin lida diretamente com estruturas de acesso.

Observe que a base $\Gamma_0$ de $\Gamma$ descreve $\Gamma$ unicamente
(e vice-versa).
O esquema de Cachin primeiro distribui uma quota do segredo para cada participante,
e depois posta, no quadro de avisos, um valor $T_X$
para cada conjunto autorizado $X \in \Gamma_0$.
Este valor será utilizado posteriormente pelos integrantes do grupo $X$
para reconstruir o segredo.

O esquema de Cachin assume a existência de uma função $f$ de via única;
isto é,
uma função $f$ tal que computar $y = f(x)$ a partir de $x$ é ``fácil'',
mas computar $x$ a partir de $y = f(x)$ é ``difícil''.
Podemos citar a exponenciação modular sobre $\mathbb Z_p$
como uma função de via única,
pois o cálculo da exponenciação pode ser feito em tempo cúbico,
enquanto que inverter a exponenciação
corresponde a resolver uma instância do logaritmo discreto.

Iremos mostrar uma variação do esquema de Cachin,
proposta por Pinch~\cite{Pinch1996}.

\begin{definition}[Esquema de Cachin-Pinch]
    Seja $p$ um número primo grande.
    O segredo $S$ será um elemento de $\mathbb Z_p^*$.

    \textbf{Etapa 1:} distribuição das quotas.
    Com cada participante $P_i \in \mathcal P$,
    o dealer combina secretamente uma quota $s_i$.
    Esta quota pode ser gerada pelo dealer
    ou ela pode ser acordada através do protocolo Diffie-Hellman,
    por exemplo.

    \textbf{Etapa 2:} geração do painel de avisos.
    Para cada conjunto $X \in \Gamma_0$,
    o dealer escolhe um gerador $g_X$ para o conjunto $\mathbb Z_p^*$,
    computa os valores
    \begin{align*}
        V_X &= g_X^{\prod_{P_i \in X} s_i} \\
        T_X &= S - f( V_X )
    \end{align*}
    e disponibiliza o par $(g_X, T_X)$
    no quadro de avisos.

    \textbf{Etapa 3:} reconstrução do segredo.
    Suponha que os participantes do grupo $X = \{P_1, \dots, P_k\}$
    se reúnam para reconstruir o segredo.
    \begin{enumerate}
        \item O participante $P_1$ obtém o valor $g_X$ do quadro de avisos,
            escolhe aleatoriamente algum número $r \in \mathbb Z_p^*$
            computa $g_X^{r s_1}$,
            e repassa para $P_2$.
            ($r$ apenas existe para que $P_1$ não precise expor $g_X^{s_1}$
            a um canal de comunicação inseguro.)

        \item Em sequência, cada participante $P_i$ ($1 < i \leq k$)
            receberá $g_X^{r * \prod_{1 \leq j < i} s_j}$ de $P_{i-1}$,
            elevará este valor a $s_i$
            (obtendo $g_X^{r * \prod_{1 \leq j \leq i} s_j}$),
            e passará para $P_{i+1}$.
            ($P_k$ deverá repassar para $P_1$.)

        \item Como $r$ é inversível,
            existe um número $w$ tal que $rw \equiv 1 \pmod p$
            (que pode ser computado eficiemente usando Euclides extendido).
            Portanto,
            assim que $P_1$ recebeber
            $g_X^{r * \prod_{1 \leq j \leq k} s_j}$,
            basta elevar este valor a $w$ para obter o valor $V_X$.
            Então, em nome do grupo,
            $P_1$ resgata $T_X$ do quadro de avisos e computa
            \begin{equation*}
                S = T_X + f(V_X).
            \end{equation*}
    \end{enumerate}
\end{definition}

\section{Outros esquemas que permitem remoção de membros}

O maior problema do esquema de Cachin é o quadro de avisos.
Para $n$ participantes,
o quadro pode ter tamanho proporcional a $2^n$
para estruturas de acesso específicas.
Existem propostas que tentam remediar isso,
mas sempre um novo problema é introduzido.

Valls, Villar e Márquez~\cite{VallsVillarMarquez1999}
constroem um protocolo de segredo compartilhado
que permite alteração na estrutura de acesso
usando apenas $O(n)$ de espaço para o quadro de avisos.
Entretanto,
a geração deste quadro de avisos é baseada
num protocolo de segredo compartilhado de Brickell,
a construção do espaço vetorial\footnote{
    Do inglês \emph{vector space construction}.
}
\cite{Brickell1990}.
O livro de Stinson~\cite[p.~499]{Stinson2006} de 2006
afirma que, para estruturas de acesso arbitrárias,
a tarefa de construir estes espaços vetoriais
só é feita por tentativa e erro
--- ou seja, este problema é intratável.
O artigo de Atici~\cite{Atici2013} de 2013
apresenta dois algoritmos para casos particulares;
mas, além de nenhum deles resolver o problema do esquema de limiar $(t, n)$,
Atici ainda diz que o caso geral requer força-bruta.

Outra abordagem para o problema é explorada por Blakley et al.%
~\cite{BlakleyBlakleyChanMassey1993}.
Eles descrevem o conceito de \emph{esquema de limiar com $L$ desregistros}%
\footnote{
    Do inglês \emph{threshold scheme with $L$-fold disenrollment capability}.
};
a ideia é que este esquema
seja capaz de invalidar até $L$ quotas diferentes após a distribuição inicial.
Blakley et al.\ não exigem que as quotas sejam imutáveis,
apenas que as mudanças das quotas possam ser transmitidas através de canais inseguros.
Neste artigo,
são estudados três esquemas com esta capacidade,
sob esta permissão de alterar as quotas dos participantes.

Por último,
mencionamos o esquema de Chen et al.~\cite{ChenGollmanMitchellWild1997},
que também exige que o número de desregistros $L$ seja escolhido de antemão,
mas a operação de invalidar uma das quotas
não exige modificação das demais quotas,
apenas do quadro de avisos.

\bibliographystyle{plain}
\bibliography{bibliografia}

\end{document}
