\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\theoremstyle{definition}
\newtheorem{definition}{Definição}
\newtheorem{example}{Exemplo}

\title{
    INE5429 --- Segurança em Computação \\
    Relatório II --- Raízes Primitivas
}
\author{
    Tiago Royer - 12100776
}

\date{28 de setembro de 2015}

\begin{document}

\maketitle

O objetivo deste trabalho é implementar um algoritmo para a geração
de raízez primitivas módulo um primo $p$
e estudar aplicações destes algoritmos para criptografia.

Todo o código está disponível em \verb"https://github.com/royertiago/INE5429".

\section{Definição}

\begin{definition}
    Dado um primo $p$,
    um número $a$ é uma \emph{raiz primitiva módulo $p$}
    se
    \begin{equation*}
        \{a^1 \bmod p, a^2 \bmod p, \dots, a^n \bmod p, \dots \} = \{1, 2, \dots, p-1\}.
    \end{equation*}
    Isto é, se as potências $a^1$, $a^2$, $a^3$ e assim por diante
    gerarem todos os números entre $1$ e $p-1$.
\end{definition}

\begin{example}
    Seja $p = 11$.
    O número $10$ não é uma raiz primitiva módulo $11$ pois
    \begin{align*}
        10^1 &\equiv 10 \pmod{11} \\
        10^2 &\equiv 1 \pmod{11} \\
        10^3 &\equiv 10 \pmod{11} \\
        ...
    \end{align*}
    Após o expoente sendo testado atingir $1$,
    os números irão se repetir,
    portanto podemos ``abortar'' o teste.

    O número $5$ também não é:
    \begin{align*}
        5^1 &\equiv 5 \pmod{11} \\
        5^2 &\equiv 3 \pmod{11} \\
        5^3 &\equiv 4 \pmod{11} \\
        5^4 &\equiv 9 \pmod{11} \\
        5^4 &\equiv 1 \pmod{11}
    \end{align*}

    Já o número $2$ é uma raiz primitiva módulo $11$:
    \begin{align*}
        2^1 &\equiv 2 \pmod{11} \\
        2^2 &\equiv 4 \pmod{11} \\
        2^3 &\equiv 8 \pmod{11} \\
        2^4 &\equiv 5 \pmod{11} \\
        2^5 &\equiv 10 \pmod{11} \\
        2^6 &\equiv 9 \pmod{11} \\
        2^7 &\equiv 7 \pmod{11} \\
        2^8 &\equiv 3 \pmod{11} \\
        2^9 &\equiv 6 \pmod{11} \\
        2^{10} &\equiv 1 \pmod{11}
    \end{align*}
\end{example}

\section{Geração de raízes primitiva módulo $p$}

Conforme o exemplo anterior,
assim que a sequência
\begin{equation*}
    a^1, a^2, a^3 \ldots
\end{equation*}
atingir o valor $1$, módulo $p$,
a sequência começa a se repetir.
O primeiro $n$ para o qual $a^n \equiv 1 \pmod p$
é chamado de \emph{ordem de $a$ módulo $p$}.
Temos o seguinte teorema.

\begin{theorem}
    A ordem de qualquer número $a$ módulo $p$ divide $\phi(p)$.
\end{theorem}

$\phi$ é a função totiente de Euler;
se $p$ é primo, $\phi(p) = p-1$.

Este teorema nos dá o seguinte algoritmo
(extraído de \cite{PrimitiveRootsStackOverflow})
para determinar se $a$ é uma raiz primitiva módulo $p$.

\begin{enumerate}
    \item Fatore $p-1$ nos primos $p_1, p_2, \ldots, p_k$.
    \item Teste, para cada $i \leq k$, se
        \begin{equation*}
            a^{(p-1)/p_i} \equiv 1 \pmod p
        \end{equation*}
        Se sim, pare: $a$ não é uma raiz primitiva módulo $p$.
    \item Se $a$ passar em todos os testes,
        $a$ é uma raiz primitiva módulo $p$.
\end{enumerate}

Observe que não precisamos calcular $a^d \pmod p$
para todos os divisores de $\phi(p)$;
todos os divisores de $\phi(p)$ terão os mesmos fatores primos de $\phi(p)$,
portanto caso $a^d \equiv 1 \pmod p$ para algum divisor $d$,
este $d$ divide algum dos números na forma $(p-1)/p_i$ testados no algoritmo,
portanto $a$ será ``pego'' ao testar $(p-1)/p_i$.

Para encontrar uma raiz primitiva módulo $p$,
então,
basta testar todos os números entre $2$ e $p-1$.

\begin{example}
    Vamos encontrar uma raiz primitiva módulo $41$.
    $\phi(41) = 40 = 2^3*5$,
    portanto precisamos testar as potências $40/2 = 20$ e $40/5 = 8$.

    Testando com $a = 2$, temos $a^{20} \equiv 1 \pmod{41}$,
    portanto $2$ não é uma raiz primitiva módulo $41$.

    Testando com $a = 3$, temos $a^{30} \equiv 40 \pmod{41}$,
    mas $a^{16} \equiv 1 \pmod{41}$,
    portanto $3$ também não é uma raiz primitiva módulo $41$.

    Podemos ignorar o caso $a = 4 = 2^2$,
    pois, se $4$ fosse uma raiz primitiva módulo $41$,
    $2$ também o seria.
    (Podemos, de fato, ignorar todas as potências perfeitas;
    entretanto,
    como potências perfeitas são raras,
    não há por que testar explicitamente contra elas na execução do algoritmo.)

    Testando com $a = 5$, temos $5^{20} \equiv 1 \pmod{41}$,
    portanto $5$ também não é raiz primitiva módulo $41$.

    Finalmente, com $a = 6$, temos $6^{20} \equiv 40 \pmod{41}$
    e $6^8 \equiv 10 \pmod{41}$,
    portanto $6$ é uma raiz primitiva módulo $41$.
\end{example}

\section{Geração de todas as raízes primitivas}

Se $a$ é uma raiz primitiva módulo $p$,
então $a^m$ será também raiz primitiva módulo $p$
se e somente se $m$ e $\phi(p)$ forem coprimos%
~\cite{PrimitiveRootsStackOverflow}.
Portanto,
dada a primeira raiz primitiva módulo $p$,
basta iterar sobre todos os valores de $m$,
filtrando os que não são coprimos a $\phi(p)$.
Testar coprimalidade pode ser feito rapidamente usando o algoritmo de Euclides,
e calcular $a^m \bmod p$ é rápido usando exponenciação modular.

\begin{example}
    Dado que $6$ é uma raiz primitiva de $41$,
    podemos gerar todas as outras:
    \begin{align*}
        6^1 &\equiv 6 \pmod{41} \\
        6^3 &\equiv 11 \pmod{41} \\
        6^7 &\equiv 29 \pmod{41} \\
        6^9 &\equiv 19 \pmod{41} \\
        6^{11} &\equiv 28 \pmod{41} \\
        6^{13} &\equiv 24 \pmod{41} \\
        6^{17} &\equiv 26 \pmod{41} \\
        6^{19} &\equiv 34 \pmod{41} \\
        6^{21} &\equiv 35 \pmod{41} \\
        6^{23} &\equiv 30 \pmod{41} \\
        6^{27} &\equiv 12 \pmod{41} \\
        6^{29} &\equiv 22 \pmod{41} \\
        6^{31} &\equiv 13 \pmod{41} \\
        6^{33} &\equiv 17 \pmod{41} \\
        6^{37} &\equiv 15 \pmod{41} \\
        6^{39} &\equiv 7 \pmod{41}
    \end{align*}
\end{example}

\section{Aplicações de raízes primitivas módulo $p$}

Dado um primo $p$ e uma raiz primitiva $a$,
todos os números $b$ com $1 \leq b \leq p-1$
podem ser escritos como $a^m$ para algum $m$ entre $1$ e $p-1$.
Reciprocamente,
todos os valores de $a^m$ serão distintos para $m$ entre $1$ e $p-1$.

Todas as aplicações de raízes primitivas
se baseiam no fato de que calcular o logaritmo discreto
é computacionalmente difícil;
isto é, para a tarefa de,
dados $a$, $p$ e $b$,
encontrar $m$ tal que
\begin{equation*}
    a^m \equiv b \pmod p,
\end{equation*}
só são conhecidos algoritmos exponenciais.

\subsection{Protocolo de troca de chaves de Diffie-Helman}

Neste protocolo,
o objetivo é gerar um número $k$ que será comum às duas partes envolvidas
(que chamaremos de Alice e Bob),
mas usando apenas um canal inseguro de comunicação.

Sejam $p$ um número primo e $a$ uma raiz primitiva módulo $p$.
Alice gera um número $A$ e Bob gera um número $B$,
e enviam os números
\begin{equation*}
    a^A \bmod p \quad \text{e} \quad a^B \bmod p
\end{equation*}
pelo canal inseguro.
Mesmo que $a$, $p$, $a^A \bmod p$ e $a^B \bmod p$ sejam descobertos,
ainda assim é computacionalmente intratável
obter os valores $A$ e $B$ individualmente.

Então, Alice calcula $(a^B)^A \equiv a^{AB} \pmod p$
usando seu número $A$,
e Bob calcula $(a^A)^B \equiv a^{AB} \pmod p$,
usando seu número $B$.
Agora,
Alice e Bob compartilham o número $k = a^{AB}$,
sem que Alice (ou possíveis intrusos) saibam $B$,
nem Bob saiba o valor $A$.

\begin{example}
    Usando $p = 41$ e $a = 6$,
    do exemplo anterior,
    podemos escolher, por exemplo, $A = 15$ e $B = 12$.
    Os números a serem transmitidos pela rede
    são $3$ e $4$,
    respectivamente;
    agora,
    podemos calcular $3^{20} \equiv 4^{15} \equiv 40 \pmod{41}$,
    que é o número em comum a Alice e Bob.
\end{example}

\bibliographystyle{plain}
\bibliography{bibliografia}

\end{document}
