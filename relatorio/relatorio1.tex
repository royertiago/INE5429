\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}

\title{
    INE5429 --- Segurança em Computação \\
    Relatório I --- Geração de Números Primos
}
\author{
    Tiago Royer - 12100776
}

\date{16 de setembro de 2015}

\begin{document}

\maketitle

O objetivo deste trabalho é gerar números primos grandes.
Números primos possuem sua importância em protocolos de segurança
porque o problema de encontrar os fatores primos de um número não-primo
é computacionalmente intratável para números grandes,
cujos fatores primos possuem milhares de bits.
Portanto, ao gerar dois números primos grandes $p$ e $q$,
mesmo que disponibilizemos para o mundo todo o produto $pq$
podemos confiar que nenhum atacante consegue fatorar este número em tempo hábil.

O trabalho pedia que implementássemos um gerador de números aleatórios
e um testador probabilístico de primalidade,
e os usasse para computar uma tabela de números primos com tamanhos arbitrários.

Todo o código está disponível em \verb"https://github.com/royertiago/INE5429".
Devido à necessidade de se trabalhar com números grandes eficientemente,
a linguagem escolhida foi C++,
tanto pela eficiência da linguagem quanto ao suporte da biblioteca GMP.

\section{Geração de números aleatórios}

O gerador escolhido foi o Xorshift,
implementado em \verb"random/xorshift.hpp".
O algoritmo aplica sucessivas vezes uma mesma transformação linear
num vetor de bits.
Devido ao formato da matriz utilizada,
esta transformação pode ser implementada muito eficientemente em inteiros de 32 bits,
ficando sempre da forma
\begin{verbatim}
    std::uint32_t t = x ^ (x << a);
    x = y; y = z; z = w;
    return w = (w ^ (w >> c)) ^ (t ^ (t >> b));
\end{verbatim}
Os valores \verb"x", \verb"y", \verb"z" e \verb"w" fazem parte do estado do gerador.
Os inteiros \verb"a", \verb"b" e \verb"c" são fixos;
eles são escolhidos de forma a garantir que o gerador possua período máximo.
(Peguei uma das sugestões do paper do criador do gerador: $a = 15$,
$b = 4$, $c = 21$.)
A primeira linha salva uma cópia (alterada) de \verb"x",
a segunda desloca o estado para a esquerda (faz o \emph{shift})
e a terceira altera os últimos 32 bits de estado,
em função dos valores originais de \verb"x" e \verb"w",
usando apenas ou-exclusivo.
Por isso o nome \emph{Xorshift}.

\subsection{Execução do gerador}

O arquivo \verb"xorshift.cpp", na raíz do repositório,
possui uma interface em linha de comando para o gerador de números aleatórios,
que permite escolher a semente inicial e a quantidade de números gerados.
(A semente padrão é baseada no tempo atual.)

Executando o comando \verb"./xorshift --x 12346 --y 1478 --z 789 --w 0 --count 20"
temos a saída
\begin{verbatim}
429712185
458348143
449052049
449051975
1950587035
2334369840
1634231841
2337152953
952165105
1644753284
894933719
3112971583
4105161773
4022965524
410405136
3180650047
2919629628
2299636233
3055551424
1770253741
\end{verbatim}

\section{Teste de primalidade}

O teste escolhido foi o de Fermat.
Este teste é baseado no pequeno teorema de Fermat:
\begin{theorem}
    Se $p$ é um número primo e $0 < a < p$, então
    \begin{equation*}
        a^{p-1} \equiv 1 (\mod p).
    \end{equation*}
\end{theorem}
A contrapositiva deste teorema é que,
se a igualdade acima não for satisfeita,
temos certeza de que o número é composto.
Neste caso,
chamamos $a$ de \emph{testemunha} para o fato de que $p$ é composto.

Agora, é possível demonstrar que,
se existe alguma testemunha,
então ao menos metade dos números entre $0$ e $p$ servirão de testemunha.
Portanto, temos um teste simples de primalidade:
chutamos $n$ valores de $a$ e testamos na equação acima.
Caso algum deles falhe,
o número é composto;
caso todos eles passem,
a probabilidade de o número ser composto é menor que $2^{-n}$.

Com $n = 30$, a chance de um número composto passar no teste
é menor que uma em um bilhão,
o que é uma probabilidade bastante aceitável.
Foi este o $n$ escolhido para concluir primalidade.

\subsection{Implementação}

Este código está no arquivo \verb"prime/fermat.hpp".
\begin{verbatim}
template< typename RNG >
bool fermat_probably_prime( mpz_class number, RNG& rng, int trials ) {
    mpz_class power, witness_candidate;

    int bytes = (mpz_sizeinbase( number.get_mpz_t(), 2 ) + 7)/8;
    mpz_class number_minus_one = number - 1;

    while( trials-- ) {
        // Generate witness candidate in range [1, n-1]
        witness_candidate = rng::gmp_generate( rng, bytes );
        witness_candidate %= number_minus_one;
        witness_candidate += 1;

        // Test witness
        power = math::pow_mod( witness_candidate, number_minus_one, number );

        if( power != 1 )
            /* Failed this trial. By Fermat's little theorem,
             * we are sure this number is not prime. */
            return false;
    }
    // Passed all trials
    return true;
}
\end{verbatim}

A função \verb"rng::gmp_generate" usa \verb"rng" para gerar um número aleatório
com a quantidade especificada de bytes.
Ela está disponível no arquivo \verb"random/gmp_adapter.hpp".

A função \verb"math::pow_mod" implementa exponenciação modular
usado quadrado-e-multiplica.
Ela está disponível no arquivo \verb"math/algo.hpp".

\subsection{Execução e comparação com Miller-Rabin}

O algoritmo de Fermat também possui uma interface em linha de comando,
no arquivo \verb"fermat_primality_test.cpp".
Por exemplo, executar \verb"./fermat_primality_test 15 3"
irá fazer $3$ tentativas de provar que $15$ não é primo.
A saída é
\begin{verbatim}
Number 15 failed Fermat test.
\end{verbatim}
Executar \verb"./fermat_primality_test 17 30", por sua vez, retorna
\begin{verbatim}
Number 17 passed all 30 trials.
\end{verbatim}

A função \verb"mpz_probab_prime" implementa o teste de Miller-Rabin.
O programa de exemplo da GMP \verb"isprime.c" é uma interface para este algoritmo.
Rodando testes entre os dois programas,
pude perceber que minha implementação demora 1m58s
para concluir que o número $2^{19937} - 1$ é provavelmente primo,
enquanto que a implementação da GMP retorna em apenas 50 segundos
(ambos os programas rodam 25 tentativas).
Já a implementação da GMP provou quue $2^{19973} - 1$ não é primo em 3 segundos,
enquanto que minha implementação tomou 5.

\end{document}
